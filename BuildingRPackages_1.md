В Windows R Core собрал пакет инструментов, которые вы можете загрузить сразу и установить с помощью простого установщика. Пакет Rtools поставляется в разных версиях, в зависимости от используемой версии R. Убедитесь, что версия Rtools соответствует вашей версии R. После ее установки у вас будет большинство инструментов, необходимых для сборки пакетов R.

https://cran.r-project.org/bin/windows/Rtools/

# R-пакеты
Пакет R — это механизм расширения базовой функциональности R. Это естественное расширение написания функций, каждая из которых хорошо выполняет определенную задачу. В предыдущей главе мы обсуждали, как написание функций абстрагирует поведение набора выражений R, предоставляя определенный интерфейс с входными данными (т. е. аргументами функции) и выходными данными (т. е. возвращаемыми значениями). Использование функций упрощает работу пользователя, поскольку ему больше не нужно знать подробности базового кода. Им нужно только понимать входы и выходы.

После разработки многих функций становится естественным сгруппировать их в наборы функций, направленных на достижение общей цели. Этот набор функций можно собрать в пакет R. Пакеты R представляют собой другой уровень абстракции, где интерфейс, представленный пользователю, представляет собой набор функций, с которыми сталкивается пользователь. Эти функции обеспечивают доступ к базовой функциональности пакета и упрощают взаимодействие с пользователем, поскольку не нужно беспокоиться о многих других необходимых вспомогательных функциях.

Пакеты R — гораздо лучший способ распространения кода среди других, поскольку они обеспечивают чистый и унифицированный пользовательский интерфейс для людей, которые хотят взаимодействовать с вашим кодом. Для пакетов R требуется документация в стандартном формате, а различные инструменты, поставляемые с R (и RStudio), помогают проверять ваши пакеты, чтобы они не содержали несоответствий или ошибок. Пользователи R уже знакомы с тем, как использовать пакеты R, поэтому они смогут быстро адаптировать ваш код, если он представлен в этом формате.

В этой главе освещаются ключевые элементы создания пакетов R. Подробные сведения о создании пакета можно найти в руководстве по написанию расширений R.

# Базовая структура пакета R
Пакет R начинает свою жизнь как каталог на вашем компьютере. Этот каталог имеет определенный макет с определенными файлами и подкаталогами. Два обязательных подкаталога:

R, который содержит все ваши файлы кода R

man, который содержит ваши файлы документации.

На верхнем уровне каталога вашего пакета у вас будут файл DESCRIPTION и файл NAMESPACE. Это минимальные требования для пакета R. Другие файлы и подкаталоги могут быть добавлены, и мы обсудим, как и почему, в разделах ниже.

Хотя RStudio не требуется для создания пакетов R, он содержит ряд удобных функций, упрощающих и ускоряющих процесс разработки. Тем не менее, чтобы использовать RStudio для разработки пакетов, вы должны правильно настроить среду. Подробности о том, как это сделать, можно найти в контрольном списке перед запуском разработки пакета RStudio от Roger .

# DESCRIPTION File
Файл DESCRIPTION является важной частью пакета R, поскольку он содержит ключевые метаданные для пакета, которые используются репозиториями, такими как CRAN, и самой R. В частности, этот файл содержит имя пакета, номер версии, контактную информацию об авторе и сопровождающем, информацию о лицензии, а также любые зависимости от других пакетов.

В качестве примера, вот файл DESCRIPTION для пакета mvtsplot на CRAN. Этот пакет предоставляет функцию для построения многомерных данных временных рядов.
```
Package:  mvtsplot
Version:  1.0-3
Date:  2016-05-13
Depends:  R (>= 3.0.0)
Imports: splines, graphics, grDevices, stats, RColorBrewer
Title:  Multivariate Time Series Plot
Author:  Roger D. Peng <rpeng@jhsph.edu>
Maintainer:  Roger D. Peng <rpeng@jhsph.edu>
Description:  A function for plotting multivariate time series data.
License:  GPL (>= 2)
URL: https://github.com/rdpeng/mvtsplot
```

# NAMESPACE File
Файл NAMESPACE определяет интерфейс пакета, представляемого пользователю. Это делается с помощью серии операторов export(), которые указывают, какие функции в пакете экспортируются пользователю. Функции, которые не экспортируются, не могут быть вызваны пользователем напрямую (хотя см. ниже). В дополнение к экспорту в файле NAMESPACE также указывается, какие функции или пакеты импортируются пакетом. Если ваш пакет зависит от функций из другого пакета, вы должны импортировать их через файл NAMESPACE.

Ниже приведен файл NAMESPACE для описанного выше пакета mvtsplot.
```
export("mvtsplot")

import(splines)
import(RColorBrewer)
importFrom("grDevices", "colorRampPalette", "gray")
importFrom("graphics", "abline", "axis", "box", "image", "layout",
           "lines", "par", "plot", "points", "segments", "strwidth",
           "text", "Axis")
importFrom("stats", "complete.cases", "lm", "na.exclude", "predict",
           "quantile")
```

Здесь мы видим, что из пакета экспортируется только одна функция (функция mvtsplot()). Существует два типа операторов импорта:

import(), просто принимает имя пакета в качестве аргумента, и интерпретация заключается в том, что все экспортированные функции из этого внешнего пакета будут доступны для вашего пакета.

importFrom() принимает пакет и ряд имен функций в качестве аргументов. Эта директива позволяет вам указать, какая именно функция вам нужна из внешнего пакета. Например, этот пакет импортирует функции colorRampPalette() и gray() из пакета grDevices.

Вообще говоря, лучше использовать importFrom() и конкретно указать, какая функция вам нужна из внешнего пакета. Однако в некоторых случаях, когда вам действительно нужны почти все функции в пакете, может быть более эффективным просто импортировать() весь пакет.

Что касается экспорта функций, важно тщательно продумать, какие функции вы хотите экспортировать. Прежде всего, экспортируемые функции должны быть документированы и поддерживаться. Пользователи обычно ожидают, что экспортированные функции будут присутствовать в последующих итерациях пакета. Обычно лучше ограничить количество экспортируемых функций (если это возможно). Всегда можно экспортировать что-то позже, если это необходимо, но удаление экспортированной функции после того, как люди привыкли к ее доступности, может расстроить пользователей. Наконец, экспорт длинного списка функций приводит к загромождению пользовательского пространства имен именами функций, которые могут конфликтовать с функциями из других пакетов.

# Namespace Function Notation
По мере того, как вы начинаете использовать множество пакетов в R, возрастает вероятность того, что две функции будут иметь одно и то же имя. Например, широко используемый пакет dplyr имеет функцию с именем filter(), которая также является именем функции в пакете stats. Если у кого-то загружены оба пакета (более чем вероятный сценарий), как можно указать, какую именно функцию filter() они хотят вызвать?

В R каждая функция имеет полное имя, которое включает пространство имен пакета как часть имени. Этот формат соответствует
```
<package name>::<exported function name>
```
Например, на функцию filter() из пакета dplyr можно ссылаться как на dplyr::filter(). Таким образом, не возникает путаницы в том, какую функцию filter() мы вызываем. Хотя, в принципе, таким образом можно ссылаться на любую функцию, это может быть утомительно для интерактивной работы. Тем не менее, для программирования часто безопаснее ссылаться на функцию, используя полное имя, если есть даже вероятность того, что может возникнуть путаница.

Можно вызывать функции, которые не экспортируются пакетом, используя нотацию пространства имен. Для этой цели можно использовать оператор :::, например <имя пакета>:::<имя неэкспортируемой функции>. Это может быть полезно для проверки кода неэкспортированной функции (например, в целях отладки) или для временного доступа к некоторым неэкспортированным функциям пакета. Однако делать это привычкой не рекомендуется, так как такие неэкспортированные функции могут быть изменены или даже удалены в будущих версиях пакета. Кроме того, использование оператора ::: не разрешено для пакетов, находящихся в CRAN.

# Загрузка и присоединение пространства имен пакета
При работе с пакетами R полезно понимать разницу между загрузкой пространства имен пакета и его присоединением. Когда пакет A импортирует пространство имен пакета B, пакет A загружает пространство имен пакета B, чтобы получить доступ к экспортированным функциям пакета B. Однако, когда пространство имен пакета B загружено, оно доступно только для пакета A; он не помещается в список поиска и не виден пользователю или другим пакетам.

Присоединение пространства имен пакета помещает это пространство имен в список поиска, делая его видимым для пользователя и других пакетов. Иногда это необходимо, потому что некоторые функции нужно сделать видимыми для пользователя, а не только для данного пакета.

# Подкаталог R
Подкаталог R содержит весь ваш код R, либо в одном файле, либо в нескольких файлах. Для больших пакетов обычно лучше всего разделить код на несколько файлов, которые логически группируют функции вместе. Имена файлов с кодом R не имеют значения, но, как правило, не рекомендуется использовать пробелы в именах файлов.

# Подкаталог man
Подкаталог man содержит файлы документации для всех экспортируемых объектов пакета. В более старых версиях R приходилось записывать документацию объектов R непосредственно в каталог man, используя нотацию в стиле LaTeX. Однако с разработкой пакета roxygen2 нам больше не нужно этого делать, и мы можем писать документацию непосредственно в файлы кода R. Поэтому вы, скорее всего, будете мало взаимодействовать с каталогом man, так как все файлы в нем будут автоматически сгенерированы пакетом roxygen2.

# Резюме
Пакеты R предоставляют удобный и стандартизированный механизм распространения кода R среди широкой аудитории. В рамках создания пакета R вы разрабатываете интерфейс для набора функций, к которым пользователи могут получить доступ, чтобы использовать предоставляемые вами функции. Пакеты R — это каталоги, содержащие код R, файлы документации, метаданные пакета и информацию об экспорте/импорте. Экспортированные функции — это функции, доступные пользователю; импортированные функции — это функции из других пакетов, которые используются вашим пакетом.

# Документация
Существует два основных типа документации, которые вы можете включить в пакеты:
Более длинные документы, содержащие руководства или обзоры всего пакета.
Более короткие файлы справки для каждой функции или группы связанных функций.
Вы можете создать документ первого типа, используя виньетки пакетов, файлы README или и то, и другое. Файлы справки для конкретных функций проще всего создать с помощью пакета roxygen2.
В этом разделе мы расскажем, зачем и как создавать эту документацию. Кроме того, виньетка/документация README может быть выполнена с помощью Knitr для создания документов R Markdown, которые смешивают код R и текст, поэтому мы включим более подробную информацию об этом процессе.

# Vignette's and README Files
Скорее всего, вы захотите создать документ, который знакомит пользователей с основами использования вашего пакета. Вы можете сделать это через два формата:

- Виньетка: этот документ связан с вашим пакетом R, поэтому он становится локально доступным для пользователя после того, как он установит ваш пакет из CRAN. Он также будет доступен, если они установят пакет из GitHub, если они используют build_vignettes = TRUE при запуске install_github.

- Файл README: если у вас есть пакет на GitHub, этот документ будет отображаться на главной странице репозитория.

Пакету, скорее всего, нужен файл README только в том случае, если вы публикуете пакет на GitHub. Для любого репозитория GitHub, если в верхнем каталоге репозитория есть файл README.md, он будет отображаться на главной странице репозитория GitHub под указанным содержимым репозитория. Например, посетите https://github.com/leighseverson/countyweather и прокрутите вниз. Вы увидите список всех файлов и подкаталогов, включенных в репозиторий пакетов, а ниже — содержимое файла README.md пакета, в котором содержится руководство по использованию пакета.

Если в файл README не нужно включать код R, вы можете написать его непосредственно в виде файла .md, используя синтаксис Markdown, который более подробно объясняется в следующем разделе. Если вы хотите включить код R, вы должны начать с файла README.Rmd, который затем можно преобразовать в Markdown с помощью Knitr. Вы можете использовать пакет devtools для добавления файла README.md или README.Rmd в каталог пакета, используя use_readme_md или use_readme_rmd соответственно. Эти функции добавят соответствующий файл на верхний уровень каталога пакета, а также добавят имя файла в «.Rbuildigore», поскольку в противном случае наличие одного из этих файлов на верхнем уровне каталога пакета может вызвать некоторые проблемы при сборке пакета. упаковка.

Файл README — это полезный способ предоставить пользователям GitHub информацию о вашем пакете, но он не будет включен в сборки пакета или доступен через CRAN для пакетов, которые там размещены. Вместо этого, если вы хотите создать учебные пособия или обзорные документы, которые включены в сборку пакета, вы должны сделать это, добавив одну или несколько виньеток пакета. Виньетки хранятся в подкаталоге виньеток внутри каталога пакета.

Чтобы добавить файл виньетки, сохраненный в этом подкаталоге (который будет создан, если у вас его еще нет), используйте функцию use_vignette из devtools. Эта функция принимает в качестве аргументов имя файла виньетки, которую вы хотите создать, и пакет, для которого вы хотите ее создать (по умолчанию это пакет в текущем рабочем каталоге). Например, если вы сейчас работаете в каталоге верхнего уровня вашего пакета и хотите добавить виньетку с именем «model_details», вы можете сделать это с помощью кода:
```
use_vignette("model_details")
```
У вас может быть более одной виньетки на пакет, что может быть полезно, если вы хотите включить одну виньетку, которая дает более общий обзор пакета, а также несколько виньеток, в которых более подробно рассматриваются конкретные аспекты или приложения.

Создав виньетку с помощью use_vignette, обязательно обновите запись индекса виньетки в YAML виньетки (код в верхней части документа R Markdown). Замените «Название виньетки» на фактическое название, которое вы используете для виньетки.

# Knitr / Markdown
Код	        Рендеринг	Объяснение
**text**	текст	    жирный шрифт
*text*	    текст	    выделен курсивом
[text](www.google.com)	текст	гиперссылка
# text		заголовок первого уровня
## text		заголовок второго уровня

Начало файла Markdown дает некоторые метаданные для файла (авторы, название, формат) на языке под названием YAML. Например, раздел YAML виньетки пакета может выглядеть так:
```
---
title: "Model Details for example_package"
author: "Jane Doe"
date: "2016-11-08"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Model Details for example_package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```
Чтобы указать код R в документе RMarkdown, вам необходимо отделить фрагмент кода, используя следующий синтаксис:

```{r}
my_vec <- 1:10
```
Вы можете указать имя для каждого фрагмента, если хотите, включив его после «r», когда вы начинаете свой фрагмент. Например, чтобы дать имя load_mtcars блоку кода, который загружает набор данных mtcars, укажите это имя в начале блока кода:
```{r load_mtcars}
data(mtcars)
```
Вот несколько советов по именованию фрагментов кода:
- Имена фрагментов должны быть уникальными в документе.
- Любые фрагменты, которые вы не называете, получают порядковые номера от Knitr.
- Вам не нужно называть каждый фрагмент. Тем не менее, есть некоторые преимущества:
- Так будет легче найти любые ошибки.
- Вы можете использовать метки фрагментов в ссылках на метки фигур.
- Вы можете ссылаться на чанки позже по имени.

# Общие параметры
Вы также можете добавить параметры при запуске чанка. Многие из этих параметров могут быть установлены как ИСТИНА / ЛОЖЬ и включают в себя: Таблица общих параметров вязания .

Чтобы включить любой из этих параметров, добавьте параметр и значение в открывающие скобки и разделите несколько параметров запятыми:

Вариант	    Действие
- echo	    Распечатать код R?
- eval	    Запустить код R?
- messages	Распечатывать сообщения?
- warnings	Распечатать предупреждения?
- include	    Если FALSE, запустить код, но не печатать код или результаты

Другие параметры блока принимают значения, отличные от TRUE/FALSE. Вот некоторые из них, которые вы, возможно, захотите включить:

Вариант	    Действие
- results	    Как распечатать результаты (например, hideзапустить код, но не распечатать результаты)
- fig.width	Ширина печати фигуры в дюймах (например, fig.width = 4)
- fig.height	Высота для печати вашей фигуры

Вы можете установить «глобальные» параметры в начале документа. Это создаст новые значения по умолчанию для всех фрагментов в документе. Например, если вы хотите, чтобы эхо, предупреждение и сообщение были FALSE по умолчанию во всех фрагментах кода, вы можете запустить:

```{r  global_options}
knitr::opts_chunk$set(echo = FALSE, message = FALSE,
  warning = FALSE)
```

Если вы установите как глобальные, так и локальные параметры чанка, которые вы задали специально для чанка, они будут иметь приоритет над глобальными параметрами. Например, запуск документа с помощью:

```{r  global_options}
knitr::opts_chunk$set(echo = FALSE, message = FALSE,
  warning = FALSE)
```


```{r  check_mtcars, echo = TRUE}
head(mtcars, 1)
```

напечатает код для блока check_mtcars, потому что опция, указанная для этого конкретного блока (echo = TRUE), переопределит глобальную опцию (echo = FALSE).

Вы также можете включить вывод R непосредственно в текст («встроенный»), используя обратные кавычки:

«В наборе данных mtcars есть наблюдения «r nrow(mtcars)». Среднее количество миль на галлон равно `r mean(mtcars$mpg, na.rm = TRUE)`».

После рендеринга файла это дает:

«В наборе данных mtcars есть 32 наблюдения. Среднее количество миль на галлон составляет 20,090625».

Вот несколько советов, которые помогут вам диагностировать некоторые проблемы с рендерингом файлов R Markdown:

Обязательно сохраните файл R Markdown перед его запуском.

Весь код в файле будет выполняться «с нуля», как если бы вы только что открыли новый сеанс R.

Код будет выполняться с использованием в качестве рабочего каталога каталога, в котором вы сохранили файл R Markdown.

Вы захотите опробовать фрагменты своего кода при написании документа R Markdown. Есть несколько способов сделать это:

Вы можете запускать код по частям так же, как вы можете запускать код из скрипта (Ctrl-Return или кнопка «Выполнить»).

Вы можете запустить весь код в чанке (или весь код во всех чанках), используя различные параметры под кнопкой «Выполнить» в RStudio.

Все параметры «Выполнить» имеют сочетания клавиш, поэтому вы можете их использовать.

Вы можете использовать этот формат для создания документации, включая виньетки, для предоставления пользователям советов и примеров использования вашего пакета.

Две отличные книги для получения дополнительной информации о создании воспроизводимых документов с помощью R — это «Динамические документы с R» и «Knitr» Yihui Xie (создателя «Knitr») и «Reproducible Research with R and RStudio» Кристофера Гандруда. Первая посвящена техническим деталям того, как работает Knitr и связанный с ним код, что дает вам инструменты для широкой настройки документа. Второй дает обширное представление о том, как использовать инструменты из R и другого программного обеспечения с открытым исходным кодом для проведения, написания и представления исследований воспроизводимым и эффективным способом. Шпаргалка по R Markdown от RStudio — еще один очень полезный справочник.